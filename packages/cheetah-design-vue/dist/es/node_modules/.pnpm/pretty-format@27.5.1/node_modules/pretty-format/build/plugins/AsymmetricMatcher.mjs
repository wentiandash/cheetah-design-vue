import { __exports as AsymmetricMatcher } from "../../../../../../../_virtual/AsymmetricMatcher.mjs";
import "../collections.mjs";
import { __exports as collections } from "../../../../../../../_virtual/collections.mjs";
Object.defineProperty(AsymmetricMatcher, "__esModule", {
  value: true
});
AsymmetricMatcher.test = AsymmetricMatcher.serialize = AsymmetricMatcher.default = void 0;
var _collections = collections;
var global = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  } else if (typeof global !== "undefined") {
    return global;
  } else if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();
var Symbol$1 = global["jest-symbol-do-not-touch"] || global.Symbol;
const asymmetricMatcher = typeof Symbol$1 === "function" && Symbol$1.for ? Symbol$1.for("jest.asymmetricMatcher") : 1267621;
const SPACE = " ";
const serialize = (val, config, indentation, depth, refs, printer) => {
  const stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return stringedValue + SPACE + "[" + (0, _collections.printListItems)(
      val.sample,
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "]";
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return stringedValue + SPACE + "{" + (0, _collections.printObjectProperties)(
      val.sample,
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "}";
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
  }
  return val.toAsymmetricMatcher();
};
AsymmetricMatcher.serialize = serialize;
const test = (val) => val && val.$$typeof === asymmetricMatcher;
AsymmetricMatcher.test = test;
const plugin = {
  serialize,
  test
};
var _default = plugin;
AsymmetricMatcher.default = _default;
//# sourceMappingURL=AsymmetricMatcher.mjs.map
