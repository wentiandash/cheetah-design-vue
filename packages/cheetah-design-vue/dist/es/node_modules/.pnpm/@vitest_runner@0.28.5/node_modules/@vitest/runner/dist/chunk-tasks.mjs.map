{"version":3,"file":"chunk-tasks.mjs","sources":["../../../../../../../../../../../node_modules/.pnpm/@vitest+runner@0.28.5/node_modules/@vitest/runner/dist/chunk-tasks.js"],"sourcesContent":["import { format, deepClone, stringify, getOwnProperties, getType, toArray } from '@vitest/utils';\n\nfunction partitionSuiteChildren(suite) {\n  let tasksGroup = [];\n  const tasksGroups = [];\n  for (const c of suite.tasks) {\n    if (tasksGroup.length === 0 || c.concurrent === tasksGroup[0].concurrent) {\n      tasksGroup.push(c);\n    } else {\n      tasksGroups.push(tasksGroup);\n      tasksGroup = [c];\n    }\n  }\n  if (tasksGroup.length > 0)\n    tasksGroups.push(tasksGroup);\n  return tasksGroups;\n}\n\nfunction interpretTaskModes(suite, namePattern, onlyMode, parentIsOnly, allowOnly) {\n  const suiteIsOnly = parentIsOnly || suite.mode === \"only\";\n  suite.tasks.forEach((t) => {\n    const includeTask = suiteIsOnly || t.mode === \"only\";\n    if (onlyMode) {\n      if (t.type === \"suite\" && (includeTask || someTasksAreOnly(t))) {\n        if (t.mode === \"only\") {\n          checkAllowOnly(t, allowOnly);\n          t.mode = \"run\";\n        }\n      } else if (t.mode === \"run\" && !includeTask) {\n        t.mode = \"skip\";\n      } else if (t.mode === \"only\") {\n        checkAllowOnly(t, allowOnly);\n        t.mode = \"run\";\n      }\n    }\n    if (t.type === \"test\") {\n      if (namePattern && !getTaskFullName(t).match(namePattern))\n        t.mode = \"skip\";\n    } else if (t.type === \"suite\") {\n      if (t.mode === \"skip\")\n        skipAllTasks(t);\n      else\n        interpretTaskModes(t, namePattern, onlyMode, includeTask, allowOnly);\n    }\n  });\n  if (suite.mode === \"run\") {\n    if (suite.tasks.length && suite.tasks.every((i) => i.mode !== \"run\"))\n      suite.mode = \"skip\";\n  }\n}\nfunction getTaskFullName(task) {\n  return `${task.suite ? `${getTaskFullName(task.suite)} ` : \"\"}${task.name}`;\n}\nfunction someTasksAreOnly(suite) {\n  return suite.tasks.some((t) => t.mode === \"only\" || t.type === \"suite\" && someTasksAreOnly(t));\n}\nfunction skipAllTasks(suite) {\n  suite.tasks.forEach((t) => {\n    if (t.mode === \"run\") {\n      t.mode = \"skip\";\n      if (t.type === \"suite\")\n        skipAllTasks(t);\n    }\n  });\n}\nfunction checkAllowOnly(task, allowOnly) {\n  if (allowOnly)\n    return;\n  const error = new Error(\"[Vitest] Unexpected .only modifier. Remove it or pass --allowOnly argument to bypass this error\");\n  task.result = {\n    state: \"fail\",\n    error,\n    errors: [error]\n  };\n}\nfunction generateHash(str) {\n  let hash = 0;\n  if (str.length === 0)\n    return `${hash}`;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return `${hash}`;\n}\nfunction calculateSuiteHash(parent) {\n  parent.tasks.forEach((t, idx) => {\n    t.id = `${parent.id}_${idx}`;\n    if (t.type === \"suite\")\n      calculateSuiteHash(t);\n  });\n}\n\nfunction createChainable(keys, fn) {\n  function create(context) {\n    const chain2 = function(...args) {\n      return fn.apply(context, args);\n    };\n    Object.assign(chain2, fn);\n    chain2.withContext = () => chain2.bind(context);\n    for (const key of keys) {\n      Object.defineProperty(chain2, key, {\n        get() {\n          return create({ ...context, [key]: true });\n        }\n      });\n    }\n    return chain2;\n  }\n  const chain = create({});\n  chain.fn = fn;\n  return chain;\n}\n\nconst IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nconst IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nconst isImmutable = (v) => v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);\nconst OBJECT_PROTO = Object.getPrototypeOf({});\nfunction getUnserializableMessage(err) {\n  if (err instanceof Error)\n    return `<unserializable>: ${err.message}`;\n  if (typeof err === \"string\")\n    return `<unserializable>: ${err}`;\n  return \"<unserializable>\";\n}\nfunction serializeError(val, seen = /* @__PURE__ */ new WeakMap()) {\n  if (!val || typeof val === \"string\")\n    return val;\n  if (typeof val === \"function\")\n    return `Function<${val.name || \"anonymous\"}>`;\n  if (typeof val === \"symbol\")\n    return val.toString();\n  if (typeof val !== \"object\")\n    return val;\n  if (isImmutable(val))\n    return serializeError(val.toJSON(), seen);\n  if (val instanceof Promise || val.constructor && val.constructor.prototype === \"AsyncFunction\")\n    return \"Promise\";\n  if (typeof Element !== \"undefined\" && val instanceof Element)\n    return val.tagName;\n  if (typeof val.asymmetricMatch === \"function\")\n    return `${val.toString()} ${format(val.sample)}`;\n  if (seen.has(val))\n    return seen.get(val);\n  if (Array.isArray(val)) {\n    const clone = new Array(val.length);\n    seen.set(val, clone);\n    val.forEach((e, i) => {\n      try {\n        clone[i] = serializeError(e, seen);\n      } catch (err) {\n        clone[i] = getUnserializableMessage(err);\n      }\n    });\n    return clone;\n  } else {\n    const clone = /* @__PURE__ */ Object.create(null);\n    seen.set(val, clone);\n    let obj = val;\n    while (obj && obj !== OBJECT_PROTO) {\n      Object.getOwnPropertyNames(obj).forEach((key) => {\n        if (key in clone)\n          return;\n        try {\n          clone[key] = serializeError(val[key], seen);\n        } catch (err) {\n          delete clone[key];\n          clone[key] = getUnserializableMessage(err);\n        }\n      });\n      obj = Object.getPrototypeOf(obj);\n    }\n    return clone;\n  }\n}\nfunction normalizeErrorMessage(message) {\n  return message.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n}\nfunction processError(err, options = {}) {\n  if (!err || typeof err !== \"object\")\n    return err;\n  if (err.stack)\n    err.stackStr = String(err.stack);\n  if (err.name)\n    err.nameStr = String(err.name);\n  const clonedActual = deepClone(err.actual);\n  const clonedExpected = deepClone(err.expected);\n  const { replacedActual, replacedExpected } = replaceAsymmetricMatcher(clonedActual, clonedExpected);\n  err.actual = replacedActual;\n  err.expected = replacedExpected;\n  const maxDiffSize = options.outputDiffMaxSize ?? 1e4;\n  if (typeof err.expected !== \"string\")\n    err.expected = stringify(err.expected, 10, { maxLength: maxDiffSize });\n  if (typeof err.actual !== \"string\")\n    err.actual = stringify(err.actual, 10, { maxLength: maxDiffSize });\n  try {\n    if (typeof err.message === \"string\")\n      err.message = normalizeErrorMessage(err.message);\n    if (typeof err.cause === \"object\" && typeof err.cause.message === \"string\")\n      err.cause.message = normalizeErrorMessage(err.cause.message);\n  } catch {\n  }\n  try {\n    return serializeError(err);\n  } catch (e) {\n    return serializeError(new Error(`Failed to fully serialize error: ${e == null ? void 0 : e.message}\nInner error message: ${err == null ? void 0 : err.message}`));\n  }\n}\nfunction isAsymmetricMatcher(data) {\n  const type = getType(data);\n  return type === \"Object\" && typeof data.asymmetricMatch === \"function\";\n}\nfunction isReplaceable(obj1, obj2) {\n  const obj1Type = getType(obj1);\n  const obj2Type = getType(obj2);\n  return obj1Type === obj2Type && obj1Type === \"Object\";\n}\nfunction replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {\n  if (!isReplaceable(actual, expected))\n    return { replacedActual: actual, replacedExpected: expected };\n  if (actualReplaced.has(actual) || expectedReplaced.has(expected))\n    return { replacedActual: actual, replacedExpected: expected };\n  actualReplaced.add(actual);\n  expectedReplaced.add(expected);\n  getOwnProperties(expected).forEach((key) => {\n    const expectedValue = expected[key];\n    const actualValue = actual[key];\n    if (isAsymmetricMatcher(expectedValue)) {\n      if (expectedValue.asymmetricMatch(actualValue))\n        actual[key] = expectedValue;\n    } else if (isAsymmetricMatcher(actualValue)) {\n      if (actualValue.asymmetricMatch(expectedValue))\n        expected[key] = actualValue;\n    } else if (isReplaceable(actualValue, expectedValue)) {\n      const replaced = replaceAsymmetricMatcher(\n        actualValue,\n        expectedValue,\n        actualReplaced,\n        expectedReplaced\n      );\n      actual[key] = replaced.replacedActual;\n      expected[key] = replaced.replacedExpected;\n    }\n  });\n  return {\n    replacedActual: actual,\n    replacedExpected: expected\n  };\n}\n\nfunction isAtomTest(s) {\n  return s.type === \"test\" || s.type === \"custom\";\n}\nfunction getTests(suite) {\n  return toArray(suite).flatMap((s) => isAtomTest(s) ? [s] : s.tasks.flatMap((c) => isAtomTest(c) ? [c] : getTests(c)));\n}\nfunction getTasks(tasks = []) {\n  return toArray(tasks).flatMap((s) => isAtomTest(s) ? [s] : [s, ...getTasks(s.tasks)]);\n}\nfunction getSuites(suite) {\n  return toArray(suite).flatMap((s) => s.type === \"suite\" ? [s, ...getSuites(s.tasks)] : []);\n}\nfunction hasTests(suite) {\n  return toArray(suite).some((s) => s.tasks.some((c) => isAtomTest(c) || hasTests(c)));\n}\nfunction hasFailed(suite) {\n  return toArray(suite).some((s) => {\n    var _a;\n    return ((_a = s.result) == null ? void 0 : _a.state) === \"fail\" || s.type === \"suite\" && hasFailed(s.tasks);\n  });\n}\nfunction getNames(task) {\n  const names = [task.name];\n  let current = task;\n  while ((current == null ? void 0 : current.suite) || (current == null ? void 0 : current.file)) {\n    current = current.suite || current.file;\n    if (current == null ? void 0 : current.name)\n      names.unshift(current.name);\n  }\n  return names;\n}\n\nexport { calculateSuiteHash as a, partitionSuiteChildren as b, createChainable as c, hasFailed as d, getTests as e, getTasks as f, generateHash as g, hasTests as h, interpretTaskModes as i, getSuites as j, getNames as k, serializeError as l, processError as p, replaceAsymmetricMatcher as r, someTasksAreOnly as s };\n"],"names":[],"mappings":"AA8FA,SAAS,gBAAgB,MAAM,IAAI;AACjC,WAAS,OAAO,SAAS;AACvB,UAAM,SAAS,YAAY,MAAM;AAC/B,aAAO,GAAG,MAAM,SAAS,IAAI;AAAA,IACnC;AACI,WAAO,OAAO,QAAQ,EAAE;AACxB,WAAO,cAAc,MAAM,OAAO,KAAK,OAAO;AAC9C,eAAW,OAAO,MAAM;AACtB,aAAO,eAAe,QAAQ,KAAK;AAAA,QACjC,MAAM;AACJ,iBAAO,OAAO,EAAE,GAAG,SAAS,CAAC,GAAG,GAAG,KAAI,CAAE;AAAA,QAC1C;AAAA,MACT,CAAO;AAAA,IACF;AACD,WAAO;AAAA,EACR;AACD,QAAM,QAAQ,OAAO,CAAA,CAAE;AACvB,QAAM,KAAK;AACX,SAAO;AACT;","x_google_ignoreList":[0]}