"use strict";
const AsymmetricMatcher = require("../../../../../../../_virtual/AsymmetricMatcher.js");
require("../collections.js");
const collections = require("../../../../../../../_virtual/collections.js");
Object.defineProperty(AsymmetricMatcher.__exports, "__esModule", {
  value: true
});
AsymmetricMatcher.__exports.test = AsymmetricMatcher.__exports.serialize = AsymmetricMatcher.__exports.default = void 0;
var _collections = collections.__exports;
var global = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  } else if (typeof global !== "undefined") {
    return global;
  } else if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();
var Symbol$1 = global["jest-symbol-do-not-touch"] || global.Symbol;
const asymmetricMatcher = typeof Symbol$1 === "function" && Symbol$1.for ? Symbol$1.for("jest.asymmetricMatcher") : 1267621;
const SPACE = " ";
const serialize = (val, config, indentation, depth, refs, printer) => {
  const stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return stringedValue + SPACE + "[" + (0, _collections.printListItems)(
      val.sample,
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "]";
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return stringedValue + SPACE + "{" + (0, _collections.printObjectProperties)(
      val.sample,
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "}";
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
  }
  return val.toAsymmetricMatcher();
};
AsymmetricMatcher.__exports.serialize = serialize;
const test = (val) => val && val.$$typeof === asymmetricMatcher;
AsymmetricMatcher.__exports.test = test;
const plugin = {
  serialize,
  test
};
var _default = plugin;
AsymmetricMatcher.__exports.default = _default;
//# sourceMappingURL=AsymmetricMatcher.js.map
