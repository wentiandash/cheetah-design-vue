{"version":3,"file":"index.js","sources":["../../../../../../../../../../../node_modules/.pnpm/@vitest+runner@0.28.5/node_modules/@vitest/runner/dist/index.js"],"sourcesContent":["import limit from 'p-limit';\nimport { getSafeTimers, format, isObject, objDisplay, objectAttr, noop, toArray, shuffle } from '@vitest/utils';\nimport { c as createChainable, g as generateHash, p as processError, a as calculateSuiteHash, s as someTasksAreOnly, i as interpretTaskModes, b as partitionSuiteChildren, h as hasTests, d as hasFailed } from './chunk-tasks.js';\nimport { relative } from 'pathe';\n\nconst fnMap = /* @__PURE__ */ new WeakMap();\nconst hooksMap = /* @__PURE__ */ new WeakMap();\nfunction setFn(key, fn) {\n  fnMap.set(key, fn);\n}\nfunction getFn(key) {\n  return fnMap.get(key);\n}\nfunction setHooks(key, hooks) {\n  hooksMap.set(key, hooks);\n}\nfunction getHooks(key) {\n  return hooksMap.get(key);\n}\n\nconst collectorContext = {\n  tasks: [],\n  currentSuite: null\n};\nfunction collectTask(task) {\n  var _a;\n  (_a = collectorContext.currentSuite) == null ? void 0 : _a.tasks.push(task);\n}\nasync function runWithSuite(suite, fn) {\n  const prev = collectorContext.currentSuite;\n  collectorContext.currentSuite = suite;\n  await fn();\n  collectorContext.currentSuite = prev;\n}\nfunction withTimeout(fn, timeout, isHook = false) {\n  if (timeout <= 0 || timeout === Infinity)\n    return fn;\n  const { setTimeout, clearTimeout } = getSafeTimers();\n  return (...args) => {\n    return Promise.race([fn(...args), new Promise((resolve, reject) => {\n      var _a;\n      const timer = setTimeout(() => {\n        clearTimeout(timer);\n        reject(new Error(makeTimeoutMsg(isHook, timeout)));\n      }, timeout);\n      (_a = timer.unref) == null ? void 0 : _a.call(timer);\n    })]);\n  };\n}\nfunction createTestContext(test, runner) {\n  var _a;\n  const context = function() {\n    throw new Error(\"done() callback is deprecated, use promise instead\");\n  };\n  context.meta = test;\n  context.onTestFailed = (fn) => {\n    test.onFailed || (test.onFailed = []);\n    test.onFailed.push(fn);\n  };\n  return ((_a = runner.extendTestContext) == null ? void 0 : _a.call(runner, context)) || context;\n}\nfunction makeTimeoutMsg(isHook, timeout) {\n  return `${isHook ? \"Hook\" : \"Test\"} timed out in ${timeout}ms.\nIf this is a long-running ${isHook ? \"hook\" : \"test\"}, pass a timeout value as the last argument or configure it globally with \"${isHook ? \"hookTimeout\" : \"testTimeout\"}\".`;\n}\n\nconst suite = createSuite();\nconst test = createTest(\n  function(name, fn, options) {\n    getCurrentSuite().test.fn.call(this, name, fn, options);\n  }\n);\nconst describe = suite;\nconst it = test;\nlet runner;\nlet defaultSuite;\nfunction getDefaultSuite() {\n  return defaultSuite;\n}\nfunction getRunner() {\n  return runner;\n}\nfunction clearCollectorContext(currentRunner) {\n  if (!defaultSuite)\n    defaultSuite = currentRunner.config.sequence.shuffle ? suite.shuffle(\"\") : suite(\"\");\n  runner = currentRunner;\n  collectorContext.tasks.length = 0;\n  defaultSuite.clear();\n  collectorContext.currentSuite = defaultSuite;\n}\nfunction getCurrentSuite() {\n  return collectorContext.currentSuite || defaultSuite;\n}\nfunction createSuiteHooks() {\n  return {\n    beforeAll: [],\n    afterAll: [],\n    beforeEach: [],\n    afterEach: []\n  };\n}\nfunction createSuiteCollector(name, factory = () => {\n}, mode, concurrent, shuffle, suiteOptions) {\n  const tasks = [];\n  const factoryQueue = [];\n  let suite2;\n  initSuite();\n  const test2 = createTest(function(name2, fn = noop, options = suiteOptions) {\n    const mode2 = this.only ? \"only\" : this.skip ? \"skip\" : this.todo ? \"todo\" : \"run\";\n    if (typeof options === \"number\")\n      options = { timeout: options };\n    const test3 = {\n      id: \"\",\n      type: \"test\",\n      name: name2,\n      mode: mode2,\n      suite: void 0,\n      fails: this.fails,\n      retry: options == null ? void 0 : options.retry\n    };\n    if (this.concurrent || concurrent)\n      test3.concurrent = true;\n    if (shuffle)\n      test3.shuffle = true;\n    const context = createTestContext(test3, runner);\n    Object.defineProperty(test3, \"context\", {\n      value: context,\n      enumerable: false\n    });\n    setFn(test3, withTimeout(\n      () => fn(context),\n      (options == null ? void 0 : options.timeout) ?? runner.config.testTimeout\n    ));\n    tasks.push(test3);\n  });\n  const custom = function(name2 = \"\") {\n    const self = this || {};\n    const task = {\n      id: \"\",\n      name: name2,\n      type: \"custom\",\n      mode: self.only ? \"only\" : self.skip ? \"skip\" : self.todo ? \"todo\" : \"run\"\n    };\n    tasks.push(task);\n    return task;\n  };\n  const collector = {\n    type: \"collector\",\n    name,\n    mode,\n    test: test2,\n    tasks,\n    collect,\n    custom,\n    clear,\n    on: addHook\n  };\n  function addHook(name2, ...fn) {\n    getHooks(suite2)[name2].push(...fn);\n  }\n  function initSuite() {\n    suite2 = {\n      id: \"\",\n      type: \"suite\",\n      name,\n      mode,\n      shuffle,\n      tasks: []\n    };\n    setHooks(suite2, createSuiteHooks());\n  }\n  function clear() {\n    tasks.length = 0;\n    factoryQueue.length = 0;\n    initSuite();\n  }\n  async function collect(file) {\n    factoryQueue.length = 0;\n    if (factory)\n      await runWithSuite(collector, () => factory(test2));\n    const allChildren = [];\n    for (const i of [...factoryQueue, ...tasks])\n      allChildren.push(i.type === \"collector\" ? await i.collect(file) : i);\n    suite2.file = file;\n    suite2.tasks = allChildren;\n    allChildren.forEach((task) => {\n      task.suite = suite2;\n      if (file)\n        task.file = file;\n    });\n    return suite2;\n  }\n  collectTask(collector);\n  return collector;\n}\nfunction createSuite() {\n  function suiteFn(name, factory, options) {\n    const mode = this.only ? \"only\" : this.skip ? \"skip\" : this.todo ? \"todo\" : \"run\";\n    return createSuiteCollector(name, factory, mode, this.concurrent, this.shuffle, options);\n  }\n  suiteFn.each = function(cases, ...args) {\n    const suite2 = this.withContext();\n    if (Array.isArray(cases) && args.length)\n      cases = formatTemplateString(cases, args);\n    return (name, fn, options) => {\n      const arrayOnlyCases = cases.every(Array.isArray);\n      cases.forEach((i, idx) => {\n        const items = Array.isArray(i) ? i : [i];\n        arrayOnlyCases ? suite2(formatTitle(name, items, idx), () => fn(...items), options) : suite2(formatTitle(name, items, idx), () => fn(i), options);\n      });\n    };\n  };\n  suiteFn.skipIf = (condition) => condition ? suite.skip : suite;\n  suiteFn.runIf = (condition) => condition ? suite : suite.skip;\n  return createChainable(\n    [\"concurrent\", \"shuffle\", \"skip\", \"only\", \"todo\"],\n    suiteFn\n  );\n}\nfunction createTest(fn) {\n  const testFn = fn;\n  testFn.each = function(cases, ...args) {\n    const test2 = this.withContext();\n    if (Array.isArray(cases) && args.length)\n      cases = formatTemplateString(cases, args);\n    return (name, fn2, options) => {\n      const arrayOnlyCases = cases.every(Array.isArray);\n      cases.forEach((i, idx) => {\n        const items = Array.isArray(i) ? i : [i];\n        arrayOnlyCases ? test2(formatTitle(name, items, idx), () => fn2(...items), options) : test2(formatTitle(name, items, idx), () => fn2(i), options);\n      });\n    };\n  };\n  testFn.skipIf = (condition) => condition ? test.skip : test;\n  testFn.runIf = (condition) => condition ? test : test.skip;\n  return createChainable(\n    [\"concurrent\", \"skip\", \"only\", \"todo\", \"fails\"],\n    testFn\n  );\n}\nfunction formatTitle(template, items, idx) {\n  if (template.includes(\"%#\")) {\n    template = template.replace(/%%/g, \"__vitest_escaped_%__\").replace(/%#/g, `${idx}`).replace(/__vitest_escaped_%__/g, \"%%\");\n  }\n  const count = template.split(\"%\").length - 1;\n  let formatted = format(template, ...items.slice(0, count));\n  if (isObject(items[0])) {\n    formatted = formatted.replace(\n      /\\$([$\\w_.]+)/g,\n      (_, key) => objDisplay(objectAttr(items[0], key))\n    );\n  }\n  return formatted;\n}\nfunction formatTemplateString(cases, args) {\n  const header = cases.join(\"\").trim().replace(/ /g, \"\").split(\"\\n\").map((i) => i.split(\"|\"))[0];\n  const res = [];\n  for (let i = 0; i < Math.floor(args.length / header.length); i++) {\n    const oneCase = {};\n    for (let j = 0; j < header.length; j++)\n      oneCase[header[j]] = args[i * header.length + j];\n    res.push(oneCase);\n  }\n  return res;\n}\n\nasync function runSetupFiles(config, runner) {\n  const files = toArray(config.setupFiles);\n  await Promise.all(\n    files.map(async (fsPath) => {\n      await runner.importFile(fsPath, \"setup\");\n    })\n  );\n}\n\nconst now$1 = Date.now;\nasync function collectTests(paths, runner) {\n  const files = [];\n  const config = runner.config;\n  for (const filepath of paths) {\n    const path = relative(config.root, filepath);\n    const file = {\n      id: generateHash(path),\n      name: path,\n      type: \"suite\",\n      mode: \"run\",\n      filepath,\n      tasks: [],\n      projectName: config.name\n    };\n    clearCollectorContext(runner);\n    try {\n      const setupStart = now$1();\n      await runSetupFiles(config, runner);\n      const collectStart = now$1();\n      file.setupDuration = collectStart - setupStart;\n      await runner.importFile(filepath, \"collect\");\n      const defaultTasks = await getDefaultSuite().collect(file);\n      setHooks(file, getHooks(defaultTasks));\n      for (const c of [...defaultTasks.tasks, ...collectorContext.tasks]) {\n        if (c.type === \"test\") {\n          file.tasks.push(c);\n        } else if (c.type === \"custom\") {\n          file.tasks.push(c);\n        } else if (c.type === \"suite\") {\n          file.tasks.push(c);\n        } else if (c.type === \"collector\") {\n          const suite = await c.collect(file);\n          if (suite.name || suite.tasks.length)\n            file.tasks.push(suite);\n        }\n      }\n      file.collectDuration = now$1() - collectStart;\n    } catch (e) {\n      const error = processError(e);\n      file.result = {\n        state: \"fail\",\n        error,\n        errors: [error]\n      };\n    }\n    calculateSuiteHash(file);\n    const hasOnlyTasks = someTasksAreOnly(file);\n    interpretTaskModes(file, config.testNamePattern, hasOnlyTasks, false, config.allowOnly);\n    files.push(file);\n  }\n  return files;\n}\n\nlet _test;\nfunction setCurrentTest(test) {\n  _test = test;\n}\nfunction getCurrentTest() {\n  return _test;\n}\n\nconst now = Date.now;\nfunction updateSuiteHookState(suite, name, state, runner) {\n  var _a;\n  if (!suite.result)\n    suite.result = { state: \"run\" };\n  if (!((_a = suite.result) == null ? void 0 : _a.hooks))\n    suite.result.hooks = {};\n  const suiteHooks = suite.result.hooks;\n  if (suiteHooks) {\n    suiteHooks[name] = state;\n    updateTask(suite, runner);\n  }\n}\nfunction getSuiteHooks(suite, name, sequence) {\n  const hooks = getHooks(suite)[name];\n  if (sequence === \"stack\" && (name === \"afterAll\" || name === \"afterEach\"))\n    return hooks.slice().reverse();\n  return hooks;\n}\nasync function callSuiteHook(suite, currentTask, name, runner, args) {\n  const sequence = runner.config.sequence.hooks;\n  const callbacks = [];\n  if (name === \"beforeEach\" && suite.suite) {\n    callbacks.push(\n      ...await callSuiteHook(suite.suite, currentTask, name, runner, args)\n    );\n  }\n  updateSuiteHookState(currentTask, name, \"run\", runner);\n  const hooks = getSuiteHooks(suite, name, sequence);\n  if (sequence === \"parallel\") {\n    callbacks.push(...await Promise.all(hooks.map((fn) => fn(...args))));\n  } else {\n    for (const hook of hooks)\n      callbacks.push(await hook(...args));\n  }\n  updateSuiteHookState(currentTask, name, \"pass\", runner);\n  if (name === \"afterEach\" && suite.suite) {\n    callbacks.push(\n      ...await callSuiteHook(suite.suite, currentTask, name, runner, args)\n    );\n  }\n  return callbacks;\n}\nconst packs = /* @__PURE__ */ new Map();\nlet updateTimer;\nlet previousUpdate;\nfunction updateTask(task, runner) {\n  packs.set(task.id, task.result);\n  const { clearTimeout, setTimeout } = getSafeTimers();\n  clearTimeout(updateTimer);\n  updateTimer = setTimeout(() => {\n    previousUpdate = sendTasksUpdate(runner);\n  }, 10);\n}\nasync function sendTasksUpdate(runner) {\n  var _a;\n  const { clearTimeout } = getSafeTimers();\n  clearTimeout(updateTimer);\n  await previousUpdate;\n  if (packs.size) {\n    const p = (_a = runner.onTaskUpdate) == null ? void 0 : _a.call(runner, Array.from(packs));\n    packs.clear();\n    return p;\n  }\n}\nconst callCleanupHooks = async (cleanups) => {\n  await Promise.all(cleanups.map(async (fn) => {\n    if (typeof fn !== \"function\")\n      return;\n    await fn();\n  }));\n};\nasync function runTest(test, runner) {\n  var _a, _b, _c, _d, _e, _f;\n  await ((_a = runner.onBeforeRunTest) == null ? void 0 : _a.call(runner, test));\n  if (test.mode !== \"run\")\n    return;\n  if (((_b = test.result) == null ? void 0 : _b.state) === \"fail\") {\n    updateTask(test, runner);\n    return;\n  }\n  const start = now();\n  test.result = {\n    state: \"run\",\n    startTime: start\n  };\n  updateTask(test, runner);\n  setCurrentTest(test);\n  const retry = test.retry || 1;\n  for (let retryCount = 0; retryCount < retry; retryCount++) {\n    let beforeEachCleanups = [];\n    try {\n      await ((_c = runner.onBeforeTryTest) == null ? void 0 : _c.call(runner, test, retryCount));\n      beforeEachCleanups = await callSuiteHook(test.suite, test, \"beforeEach\", runner, [test.context, test.suite]);\n      test.result.retryCount = retryCount;\n      if (runner.runTest) {\n        await runner.runTest(test);\n      } else {\n        const fn = getFn(test);\n        if (!fn)\n          throw new Error(\"Test function is not found. Did you add it using `setFn`?\");\n        await fn();\n      }\n      await ((_d = runner.onAfterTryTest) == null ? void 0 : _d.call(runner, test, retryCount));\n      test.result.state = \"pass\";\n    } catch (e) {\n      failTask(test.result, e);\n    }\n    try {\n      await callSuiteHook(test.suite, test, \"afterEach\", runner, [test.context, test.suite]);\n      await callCleanupHooks(beforeEachCleanups);\n    } catch (e) {\n      failTask(test.result, e);\n    }\n    if (test.result.state === \"pass\")\n      break;\n    updateTask(test, runner);\n  }\n  if (test.result.state === \"fail\")\n    await Promise.all(((_e = test.onFailed) == null ? void 0 : _e.map((fn) => fn(test.result))) || []);\n  if (test.fails) {\n    if (test.result.state === \"pass\") {\n      const error = processError(new Error(\"Expect test to fail\"));\n      test.result.state = \"fail\";\n      test.result.error = error;\n      test.result.errors = [error];\n    } else {\n      test.result.state = \"pass\";\n      test.result.error = void 0;\n      test.result.errors = void 0;\n    }\n  }\n  setCurrentTest(void 0);\n  test.result.duration = now() - start;\n  await ((_f = runner.onAfterRunTest) == null ? void 0 : _f.call(runner, test));\n  updateTask(test, runner);\n}\nfunction failTask(result, err) {\n  result.state = \"fail\";\n  const error = processError(err);\n  result.error = error;\n  result.errors ?? (result.errors = []);\n  result.errors.push(error);\n}\nfunction markTasksAsSkipped(suite, runner) {\n  suite.tasks.forEach((t) => {\n    t.mode = \"skip\";\n    t.result = { ...t.result, state: \"skip\" };\n    updateTask(t, runner);\n    if (t.type === \"suite\")\n      markTasksAsSkipped(t, runner);\n  });\n}\nasync function runSuite(suite, runner) {\n  var _a, _b, _c;\n  await ((_a = runner.onBeforeRunSuite) == null ? void 0 : _a.call(runner, suite));\n  if (((_b = suite.result) == null ? void 0 : _b.state) === \"fail\") {\n    markTasksAsSkipped(suite, runner);\n    updateTask(suite, runner);\n    return;\n  }\n  const start = now();\n  suite.result = {\n    state: \"run\",\n    startTime: start\n  };\n  updateTask(suite, runner);\n  let beforeAllCleanups = [];\n  if (suite.mode === \"skip\") {\n    suite.result.state = \"skip\";\n  } else if (suite.mode === \"todo\") {\n    suite.result.state = \"todo\";\n  } else {\n    try {\n      beforeAllCleanups = await callSuiteHook(suite, suite, \"beforeAll\", runner, [suite]);\n      if (runner.runSuite) {\n        await runner.runSuite(suite);\n      } else {\n        for (let tasksGroup of partitionSuiteChildren(suite)) {\n          if (tasksGroup[0].concurrent === true) {\n            const mutex = limit(runner.config.maxConcurrency);\n            await Promise.all(tasksGroup.map((c) => mutex(() => runSuiteChild(c, runner))));\n          } else {\n            const { sequence } = runner.config;\n            if (sequence.shuffle || suite.shuffle) {\n              const suites = tasksGroup.filter((group) => group.type === \"suite\");\n              const tests = tasksGroup.filter((group) => group.type === \"test\");\n              const groups = shuffle([suites, tests], sequence.seed);\n              tasksGroup = groups.flatMap((group) => shuffle(group, sequence.seed));\n            }\n            for (const c of tasksGroup)\n              await runSuiteChild(c, runner);\n          }\n        }\n      }\n    } catch (e) {\n      failTask(suite.result, e);\n    }\n    try {\n      await callSuiteHook(suite, suite, \"afterAll\", runner, [suite]);\n      await callCleanupHooks(beforeAllCleanups);\n    } catch (e) {\n      failTask(suite.result, e);\n    }\n  }\n  suite.result.duration = now() - start;\n  if (suite.mode === \"run\") {\n    if (!hasTests(suite)) {\n      suite.result.state = \"fail\";\n      if (!suite.result.error) {\n        const error = processError(new Error(`No test found in suite ${suite.name}`));\n        suite.result.error = error;\n        suite.result.errors = [error];\n      }\n    } else if (hasFailed(suite)) {\n      suite.result.state = \"fail\";\n    } else {\n      suite.result.state = \"pass\";\n    }\n  }\n  await ((_c = runner.onAfterRunSuite) == null ? void 0 : _c.call(runner, suite));\n  updateTask(suite, runner);\n}\nasync function runSuiteChild(c, runner) {\n  if (c.type === \"test\")\n    return runTest(c, runner);\n  else if (c.type === \"suite\")\n    return runSuite(c, runner);\n}\nasync function runFiles(files, runner) {\n  var _a, _b;\n  for (const file of files) {\n    if (!file.tasks.length && !runner.config.passWithNoTests) {\n      if (!((_b = (_a = file.result) == null ? void 0 : _a.errors) == null ? void 0 : _b.length)) {\n        const error = processError(new Error(`No test suite found in file ${file.filepath}`));\n        file.result = {\n          state: \"fail\",\n          error,\n          errors: [error]\n        };\n      }\n    }\n    await runSuite(file, runner);\n  }\n}\nasync function startTests(paths, runner) {\n  var _a, _b, _c, _d;\n  await ((_a = runner.onBeforeCollect) == null ? void 0 : _a.call(runner, paths));\n  const files = await collectTests(paths, runner);\n  (_b = runner.onCollected) == null ? void 0 : _b.call(runner, files);\n  await ((_c = runner.onBeforeRun) == null ? void 0 : _c.call(runner, files));\n  await runFiles(files, runner);\n  await ((_d = runner.onAfterRun) == null ? void 0 : _d.call(runner, files));\n  await sendTasksUpdate(runner);\n  return files;\n}\n\nconst getDefaultHookTimeout = () => getRunner().config.hookTimeout;\nconst beforeAll = (fn, timeout) => getCurrentSuite().on(\"beforeAll\", withTimeout(fn, timeout ?? getDefaultHookTimeout(), true));\nconst afterAll = (fn, timeout) => getCurrentSuite().on(\"afterAll\", withTimeout(fn, timeout ?? getDefaultHookTimeout(), true));\nconst beforeEach = (fn, timeout) => getCurrentSuite().on(\"beforeEach\", withTimeout(fn, timeout ?? getDefaultHookTimeout(), true));\nconst afterEach = (fn, timeout) => getCurrentSuite().on(\"afterEach\", withTimeout(fn, timeout ?? getDefaultHookTimeout(), true));\nconst onTestFailed = createTestHook(\"onTestFailed\", (test, handler) => {\n  test.onFailed || (test.onFailed = []);\n  test.onFailed.push(handler);\n});\nfunction createTestHook(name, handler) {\n  return (fn) => {\n    const current = getCurrentTest();\n    if (!current)\n      throw new Error(`Hook ${name}() can only be called inside a test`);\n    handler(current, fn);\n  };\n}\n\nexport { afterAll, afterEach, beforeAll, beforeEach, describe, getCurrentSuite, getFn, it, onTestFailed, setFn, startTests, suite, test, updateTask };\n"],"names":["suite","getSafeTimers","test","runner","noop","createChainable","format","isObject","objDisplay","objectAttr"],"mappings":";;;;;AAKA,MAAM,QAAwB,oBAAI;AAClC,MAAM,WAA2B,oBAAI;AACrC,SAAS,MAAM,KAAK,IAAI;AACtB,QAAM,IAAI,KAAK,EAAE;AACnB;AAIA,SAAS,SAAS,KAAK,OAAO;AAC5B,WAAS,IAAI,KAAK,KAAK;AACzB;AACA,SAAS,SAAS,KAAK;AACrB,SAAO,SAAS,IAAI,GAAG;AACzB;AAEA,MAAM,mBAAmB;AAAA,EACvB,OAAO,CAAE;AAAA,EACT,cAAc;AAChB;AACA,SAAS,YAAY,MAAM;AACzB,MAAI;AACJ,GAAC,KAAK,iBAAiB,iBAAiB,OAAO,SAAS,GAAG,MAAM,KAAK,IAAI;AAC5E;AACA,eAAe,aAAaA,QAAO,IAAI;AACrC,QAAM,OAAO,iBAAiB;AAC9B,mBAAiB,eAAeA;AAChC,QAAM,GAAE;AACR,mBAAiB,eAAe;AAClC;AACA,SAAS,YAAY,IAAI,SAAS,SAAS,OAAO;AAChD,MAAI,WAAW,KAAK,YAAY;AAC9B,WAAO;AACT,QAAM,EAAE,YAAY,aAAc,IAAGC,MAAa,cAAA;AAClD,SAAO,IAAI,SAAS;AAClB,WAAO,QAAQ,KAAK,CAAC,GAAG,GAAG,IAAI,GAAG,IAAI,QAAQ,CAAC,SAAS,WAAW;AACjE,UAAI;AACJ,YAAM,QAAQ,WAAW,MAAM;AAC7B,qBAAa,KAAK;AAClB,eAAO,IAAI,MAAM,eAAe,QAAQ,OAAO,CAAC,CAAC;AAAA,MAClD,GAAE,OAAO;AACV,OAAC,KAAK,MAAM,UAAU,OAAO,SAAS,GAAG,KAAK,KAAK;AAAA,IACpD,CAAA,CAAC,CAAC;AAAA,EACP;AACA;AACA,SAAS,kBAAkBC,OAAMC,SAAQ;AACvC,MAAI;AACJ,QAAM,UAAU,WAAW;AACzB,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACxE;AACE,UAAQ,OAAOD;AACf,UAAQ,eAAe,CAAC,OAAO;AAC7B,IAAAA,MAAK,aAAaA,MAAK,WAAW,CAAE;AACpC,IAAAA,MAAK,SAAS,KAAK,EAAE;AAAA,EACzB;AACE,WAAS,KAAKC,QAAO,sBAAsB,OAAO,SAAS,GAAG,KAAKA,SAAQ,OAAO,MAAM;AAC1F;AACA,SAAS,eAAe,QAAQ,SAAS;AACvC,SAAO,GAAG,SAAS,SAAS,MAAM,iBAAiB,OAAO;AAAA,4BAChC,SAAS,SAAS,MAAM,8EAA8E,SAAS,gBAAgB,aAAa;AACxK;AAEK,MAAC,QAAQ,YAAc;AACvB,MAAC,OAAO;AAAA,EACX,SAAS,MAAM,IAAI,SAAS;AAC1B,oBAAiB,EAAC,KAAK,GAAG,KAAK,MAAM,MAAM,IAAI,OAAO;AAAA,EACvD;AACH;AACK,MAAC,WAAW;AACZ,MAAC,KAAK;AACX,IAAI;AACJ,IAAI;AAeJ,SAAS,kBAAkB;AACzB,SAAO,iBAAiB,gBAAgB;AAC1C;AACA,SAAS,mBAAmB;AAC1B,SAAO;AAAA,IACL,WAAW,CAAE;AAAA,IACb,UAAU,CAAE;AAAA,IACZ,YAAY,CAAE;AAAA,IACd,WAAW,CAAE;AAAA,EACjB;AACA;AACA,SAAS,qBAAqB,MAAM,UAAU,MAAM;AACpD,GAAG,MAAM,YAAY,SAAS,cAAc;AAC1C,QAAM,QAAQ,CAAA;AACd,QAAM,eAAe,CAAA;AACrB,MAAI;AACJ;AACA,QAAM,QAAQ,WAAW,SAAS,OAAO,KAAKC,QAAI,MAAE,UAAU,cAAc;AAC1E,UAAM,QAAQ,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS;AAC7E,QAAI,OAAO,YAAY;AACrB,gBAAU,EAAE,SAAS;AACvB,UAAM,QAAQ;AAAA,MACZ,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO,KAAK;AAAA,MACZ,OAAO,WAAW,OAAO,SAAS,QAAQ;AAAA,IAChD;AACI,QAAI,KAAK,cAAc;AACrB,YAAM,aAAa;AACrB,QAAI;AACF,YAAM,UAAU;AAClB,UAAM,UAAU,kBAAkB,OAAO,MAAM;AAC/C,WAAO,eAAe,OAAO,WAAW;AAAA,MACtC,OAAO;AAAA,MACP,YAAY;AAAA,IAClB,CAAK;AACD,UAAM,OAAO;AAAA,MACX,MAAM,GAAG,OAAO;AAAA,OACf,WAAW,OAAO,SAAS,QAAQ,YAAY,OAAO,OAAO;AAAA,IACpE,CAAK;AACD,UAAM,KAAK,KAAK;AAAA,EACpB,CAAG;AACD,QAAM,SAAS,SAAS,QAAQ,IAAI;AAClC,UAAM,OAAO,QAAQ;AACrB,UAAM,OAAO;AAAA,MACX,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS;AAAA,IAC3E;AACI,UAAM,KAAK,IAAI;AACf,WAAO;AAAA,EACX;AACE,QAAM,YAAY;AAAA,IAChB,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,IAAI;AAAA,EACR;AACE,WAAS,QAAQ,UAAU,IAAI;AAC7B,aAAS,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,EAAE;AAAA,EACnC;AACD,WAAS,YAAY;AACnB,aAAS;AAAA,MACP,IAAI;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,CAAE;AAAA,IACf;AACI,aAAS,QAAQ,iBAAgB,CAAE;AAAA,EACpC;AACD,WAAS,QAAQ;AACf,UAAM,SAAS;AACf,iBAAa,SAAS;AACtB;EACD;AACD,iBAAe,QAAQ,MAAM;AAC3B,iBAAa,SAAS;AACtB,QAAI;AACF,YAAM,aAAa,WAAW,MAAM,QAAQ,KAAK,CAAC;AACpD,UAAM,cAAc,CAAA;AACpB,eAAW,KAAK,CAAC,GAAG,cAAc,GAAG,KAAK;AACxC,kBAAY,KAAK,EAAE,SAAS,cAAc,MAAM,EAAE,QAAQ,IAAI,IAAI,CAAC;AACrE,WAAO,OAAO;AACd,WAAO,QAAQ;AACf,gBAAY,QAAQ,CAAC,SAAS;AAC5B,WAAK,QAAQ;AACb,UAAI;AACF,aAAK,OAAO;AAAA,IACpB,CAAK;AACD,WAAO;AAAA,EACR;AACD,cAAY,SAAS;AACrB,SAAO;AACT;AACA,SAAS,cAAc;AACrB,WAAS,QAAQ,MAAM,SAAS,SAAS;AACvC,UAAM,OAAO,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS;AAC5E,WAAO,qBAAqB,MAAM,SAAS,MAAM,KAAK,YAAY,KAAK,SAAS,OAAO;AAAA,EACxF;AACD,UAAQ,OAAO,SAAS,UAAU,MAAM;AACtC,UAAM,SAAS,KAAK;AACpB,QAAI,MAAM,QAAQ,KAAK,KAAK,KAAK;AAC/B,cAAQ,qBAAqB,OAAO,IAAI;AAC1C,WAAO,CAAC,MAAM,IAAI,YAAY;AAC5B,YAAM,iBAAiB,MAAM,MAAM,MAAM,OAAO;AAChD,YAAM,QAAQ,CAAC,GAAG,QAAQ;AACxB,cAAM,QAAQ,MAAM,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC;AACvC,yBAAiB,OAAO,YAAY,MAAM,OAAO,GAAG,GAAG,MAAM,GAAG,GAAG,KAAK,GAAG,OAAO,IAAI,OAAO,YAAY,MAAM,OAAO,GAAG,GAAG,MAAM,GAAG,CAAC,GAAG,OAAO;AAAA,MACxJ,CAAO;AAAA,IACP;AAAA,EACA;AACE,UAAQ,SAAS,CAAC,cAAc,YAAY,MAAM,OAAO;AACzD,UAAQ,QAAQ,CAAC,cAAc,YAAY,QAAQ,MAAM;AACzD,SAAOC,WAAe;AAAA,IACpB,CAAC,cAAc,WAAW,QAAQ,QAAQ,MAAM;AAAA,IAChD;AAAA,EACJ;AACA;AACA,SAAS,WAAW,IAAI;AACtB,QAAM,SAAS;AACf,SAAO,OAAO,SAAS,UAAU,MAAM;AACrC,UAAM,QAAQ,KAAK;AACnB,QAAI,MAAM,QAAQ,KAAK,KAAK,KAAK;AAC/B,cAAQ,qBAAqB,OAAO,IAAI;AAC1C,WAAO,CAAC,MAAM,KAAK,YAAY;AAC7B,YAAM,iBAAiB,MAAM,MAAM,MAAM,OAAO;AAChD,YAAM,QAAQ,CAAC,GAAG,QAAQ;AACxB,cAAM,QAAQ,MAAM,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC;AACvC,yBAAiB,MAAM,YAAY,MAAM,OAAO,GAAG,GAAG,MAAM,IAAI,GAAG,KAAK,GAAG,OAAO,IAAI,MAAM,YAAY,MAAM,OAAO,GAAG,GAAG,MAAM,IAAI,CAAC,GAAG,OAAO;AAAA,MACxJ,CAAO;AAAA,IACP;AAAA,EACA;AACE,SAAO,SAAS,CAAC,cAAc,YAAY,KAAK,OAAO;AACvD,SAAO,QAAQ,CAAC,cAAc,YAAY,OAAO,KAAK;AACtD,SAAOA,WAAe;AAAA,IACpB,CAAC,cAAc,QAAQ,QAAQ,QAAQ,OAAO;AAAA,IAC9C;AAAA,EACJ;AACA;AACA,SAAS,YAAY,UAAU,OAAO,KAAK;AACzC,MAAI,SAAS,SAAS,IAAI,GAAG;AAC3B,eAAW,SAAS,QAAQ,OAAO,sBAAsB,EAAE,QAAQ,OAAO,GAAG,GAAG,EAAE,EAAE,QAAQ,yBAAyB,IAAI;AAAA,EAC1H;AACD,QAAM,QAAQ,SAAS,MAAM,GAAG,EAAE,SAAS;AAC3C,MAAI,YAAYC,MAAM,OAAC,UAAU,GAAG,MAAM,MAAM,GAAG,KAAK,CAAC;AACzD,MAAIC,iBAAS,MAAM,CAAC,CAAC,GAAG;AACtB,gBAAY,UAAU;AAAA,MACpB;AAAA,MACA,CAAC,GAAG,QAAQC,iBAAWC,QAAAA,WAAW,MAAM,CAAC,GAAG,GAAG,CAAC;AAAA,IACtD;AAAA,EACG;AACD,SAAO;AACT;AACA,SAAS,qBAAqB,OAAO,MAAM;AACzC,QAAM,SAAS,MAAM,KAAK,EAAE,EAAE,OAAO,QAAQ,MAAM,EAAE,EAAE,MAAM,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC;AAC7F,QAAM,MAAM,CAAA;AACZ,WAAS,IAAI,GAAG,IAAI,KAAK,MAAM,KAAK,SAAS,OAAO,MAAM,GAAG,KAAK;AAChE,UAAM,UAAU,CAAA;AAChB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ;AACjC,cAAQ,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,OAAO,SAAS,CAAC;AACjD,QAAI,KAAK,OAAO;AAAA,EACjB;AACD,SAAO;AACT;;;;;;;","x_google_ignoreList":[0]}