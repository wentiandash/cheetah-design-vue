"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const compilerCore_esmBundler = require("../../../../../@vue_compiler-core@3.3.4/node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
const shared = require("@vue/shared");
const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(``);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(``);
const V_MODEL_DYNAMIC = Symbol(``);
const V_ON_WITH_MODIFIERS = Symbol(``);
const V_ON_WITH_KEYS = Symbol(``);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(``);
compilerCore_esmBundler.registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const isRawTextContainer = /* @__PURE__ */ shared.makeMap(
  "style,iframe,script,noscript",
  true
);
const parserOptions = {
  isVoidTag: shared.isVoidTag,
  isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (compilerCore_esmBundler.isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (compilerCore_esmBundler.isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : 0;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag, ns }) {
    if (ns === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: compilerCore_esmBundler.createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = shared.parseStringStyle(cssText);
  return compilerCore_esmBundler.createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};
function createDOMCompilerError(code, loc) {
  return compilerCore_esmBundler.createCompilerError(
    code,
    loc
  );
}
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      compilerCore_esmBundler.createObjectProperty(
        compilerCore_esmBundler.createSimpleExpression(`innerHTML`, true, loc),
        exp || compilerCore_esmBundler.createSimpleExpression("", true)
      )
    ]
  };
};
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      compilerCore_esmBundler.createObjectProperty(
        compilerCore_esmBundler.createSimpleExpression(`textContent`, true),
        exp ? compilerCore_esmBundler.getConstantType(exp, context) > 0 ? exp : compilerCore_esmBundler.createCallExpression(
          context.helperString(compilerCore_esmBundler.TO_DISPLAY_STRING),
          [exp],
          loc
        ) : compilerCore_esmBundler.createSimpleExpression("", true)
      )
    ]
  };
};
const transformModel = (dir, node, context) => {
  const baseResult = compilerCore_esmBundler.transformModel(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = compilerCore_esmBundler.findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
          }
        }
      } else if (compilerCore_esmBundler.hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else
        ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else
      ;
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ shared.makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ shared.makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i];
    if (modifier === "native" && compilerCore_esmBundler.checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (compilerCore_esmBundler.isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = compilerCore_esmBundler.isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? compilerCore_esmBundler.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore_esmBundler.createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return compilerCore_esmBundler.transformOn(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = compilerCore_esmBundler.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!compilerCore_esmBundler.isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = compilerCore_esmBundler.createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
      key = compilerCore_esmBundler.isStaticExp(key) ? compilerCore_esmBundler.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore_esmBundler.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [compilerCore_esmBundler.createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: compilerCore_esmBundler.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(template, options = {}) {
  return compilerCore_esmBundler.baseCompile(
    template,
    shared.extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: shared.extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
exports.BASE_TRANSITION = compilerCore_esmBundler.BASE_TRANSITION;
exports.CAMELIZE = compilerCore_esmBundler.CAMELIZE;
exports.CAPITALIZE = compilerCore_esmBundler.CAPITALIZE;
exports.CREATE_BLOCK = compilerCore_esmBundler.CREATE_BLOCK;
exports.CREATE_COMMENT = compilerCore_esmBundler.CREATE_COMMENT;
exports.CREATE_ELEMENT_BLOCK = compilerCore_esmBundler.CREATE_ELEMENT_BLOCK;
exports.CREATE_ELEMENT_VNODE = compilerCore_esmBundler.CREATE_ELEMENT_VNODE;
exports.CREATE_SLOTS = compilerCore_esmBundler.CREATE_SLOTS;
exports.CREATE_STATIC = compilerCore_esmBundler.CREATE_STATIC;
exports.CREATE_TEXT = compilerCore_esmBundler.CREATE_TEXT;
exports.CREATE_VNODE = compilerCore_esmBundler.CREATE_VNODE;
exports.FRAGMENT = compilerCore_esmBundler.FRAGMENT;
exports.GUARD_REACTIVE_PROPS = compilerCore_esmBundler.GUARD_REACTIVE_PROPS;
exports.IS_MEMO_SAME = compilerCore_esmBundler.IS_MEMO_SAME;
exports.IS_REF = compilerCore_esmBundler.IS_REF;
exports.KEEP_ALIVE = compilerCore_esmBundler.KEEP_ALIVE;
exports.MERGE_PROPS = compilerCore_esmBundler.MERGE_PROPS;
exports.NORMALIZE_CLASS = compilerCore_esmBundler.NORMALIZE_CLASS;
exports.NORMALIZE_PROPS = compilerCore_esmBundler.NORMALIZE_PROPS;
exports.NORMALIZE_STYLE = compilerCore_esmBundler.NORMALIZE_STYLE;
exports.OPEN_BLOCK = compilerCore_esmBundler.OPEN_BLOCK;
exports.POP_SCOPE_ID = compilerCore_esmBundler.POP_SCOPE_ID;
exports.PUSH_SCOPE_ID = compilerCore_esmBundler.PUSH_SCOPE_ID;
exports.RENDER_LIST = compilerCore_esmBundler.RENDER_LIST;
exports.RENDER_SLOT = compilerCore_esmBundler.RENDER_SLOT;
exports.RESOLVE_COMPONENT = compilerCore_esmBundler.RESOLVE_COMPONENT;
exports.RESOLVE_DIRECTIVE = compilerCore_esmBundler.RESOLVE_DIRECTIVE;
exports.RESOLVE_DYNAMIC_COMPONENT = compilerCore_esmBundler.RESOLVE_DYNAMIC_COMPONENT;
exports.RESOLVE_FILTER = compilerCore_esmBundler.RESOLVE_FILTER;
exports.SET_BLOCK_TRACKING = compilerCore_esmBundler.SET_BLOCK_TRACKING;
exports.SUSPENSE = compilerCore_esmBundler.SUSPENSE;
exports.TELEPORT = compilerCore_esmBundler.TELEPORT;
exports.TO_DISPLAY_STRING = compilerCore_esmBundler.TO_DISPLAY_STRING;
exports.TO_HANDLERS = compilerCore_esmBundler.TO_HANDLERS;
exports.TO_HANDLER_KEY = compilerCore_esmBundler.TO_HANDLER_KEY;
exports.UNREF = compilerCore_esmBundler.UNREF;
exports.WITH_CTX = compilerCore_esmBundler.WITH_CTX;
exports.WITH_DIRECTIVES = compilerCore_esmBundler.WITH_DIRECTIVES;
exports.WITH_MEMO = compilerCore_esmBundler.WITH_MEMO;
exports.advancePositionWithClone = compilerCore_esmBundler.advancePositionWithClone;
exports.advancePositionWithMutation = compilerCore_esmBundler.advancePositionWithMutation;
exports.baseCompile = compilerCore_esmBundler.baseCompile;
exports.baseParse = compilerCore_esmBundler.baseParse;
exports.buildDirectiveArgs = compilerCore_esmBundler.buildDirectiveArgs;
exports.buildProps = compilerCore_esmBundler.buildProps;
exports.buildSlots = compilerCore_esmBundler.buildSlots;
exports.checkCompatEnabled = compilerCore_esmBundler.checkCompatEnabled;
exports.convertToBlock = compilerCore_esmBundler.convertToBlock;
exports.createArrayExpression = compilerCore_esmBundler.createArrayExpression;
exports.createBlockStatement = compilerCore_esmBundler.createBlockStatement;
exports.createCacheExpression = compilerCore_esmBundler.createCacheExpression;
exports.createCallExpression = compilerCore_esmBundler.createCallExpression;
exports.createCompilerError = compilerCore_esmBundler.createCompilerError;
exports.createCompoundExpression = compilerCore_esmBundler.createCompoundExpression;
exports.createConditionalExpression = compilerCore_esmBundler.createConditionalExpression;
exports.createForLoopParams = compilerCore_esmBundler.createForLoopParams;
exports.createFunctionExpression = compilerCore_esmBundler.createFunctionExpression;
exports.createObjectExpression = compilerCore_esmBundler.createObjectExpression;
exports.createObjectProperty = compilerCore_esmBundler.createObjectProperty;
exports.createRoot = compilerCore_esmBundler.createRoot;
exports.createSimpleExpression = compilerCore_esmBundler.createSimpleExpression;
exports.createStructuralDirectiveTransform = compilerCore_esmBundler.createStructuralDirectiveTransform;
exports.createTransformContext = compilerCore_esmBundler.createTransformContext;
exports.createVNodeCall = compilerCore_esmBundler.createVNodeCall;
exports.findDir = compilerCore_esmBundler.findDir;
exports.findProp = compilerCore_esmBundler.findProp;
exports.generate = compilerCore_esmBundler.generate;
exports.getBaseTransformPreset = compilerCore_esmBundler.getBaseTransformPreset;
exports.getConstantType = compilerCore_esmBundler.getConstantType;
exports.getInnerRange = compilerCore_esmBundler.getInnerRange;
exports.getMemoedVNodeCall = compilerCore_esmBundler.getMemoedVNodeCall;
exports.getVNodeBlockHelper = compilerCore_esmBundler.getVNodeBlockHelper;
exports.getVNodeHelper = compilerCore_esmBundler.getVNodeHelper;
exports.hasDynamicKeyVBind = compilerCore_esmBundler.hasDynamicKeyVBind;
exports.helperNameMap = compilerCore_esmBundler.helperNameMap;
exports.injectProp = compilerCore_esmBundler.injectProp;
exports.isBuiltInType = compilerCore_esmBundler.isBuiltInType;
exports.isCoreComponent = compilerCore_esmBundler.isCoreComponent;
exports.isMemberExpression = compilerCore_esmBundler.isMemberExpression;
exports.isMemberExpressionBrowser = compilerCore_esmBundler.isMemberExpressionBrowser;
exports.isSimpleIdentifier = compilerCore_esmBundler.isSimpleIdentifier;
exports.isSlotOutlet = compilerCore_esmBundler.isSlotOutlet;
exports.isStaticArgOf = compilerCore_esmBundler.isStaticArgOf;
exports.isStaticExp = compilerCore_esmBundler.isStaticExp;
exports.isTemplateNode = compilerCore_esmBundler.isTemplateNode;
exports.isText = compilerCore_esmBundler.isText;
exports.isVSlot = compilerCore_esmBundler.isVSlot;
exports.locStub = compilerCore_esmBundler.locStub;
exports.noopDirectiveTransform = compilerCore_esmBundler.noopDirectiveTransform;
exports.processFor = compilerCore_esmBundler.processFor;
exports.processIf = compilerCore_esmBundler.processIf;
exports.processSlotOutlet = compilerCore_esmBundler.processSlotOutlet;
exports.registerRuntimeHelpers = compilerCore_esmBundler.registerRuntimeHelpers;
exports.resolveComponentType = compilerCore_esmBundler.resolveComponentType;
exports.toValidAssetId = compilerCore_esmBundler.toValidAssetId;
exports.trackSlotScopes = compilerCore_esmBundler.trackSlotScopes;
exports.transform = compilerCore_esmBundler.transform;
exports.transformBind = compilerCore_esmBundler.transformBind;
exports.transformElement = compilerCore_esmBundler.transformElement;
exports.transformModel = compilerCore_esmBundler.transformModel;
exports.transformOn = compilerCore_esmBundler.transformOn;
exports.traverseNode = compilerCore_esmBundler.traverseNode;
Object.defineProperty(exports, "generateCodeFrame", {
  enumerable: true,
  get: () => shared.generateCodeFrame
});
exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
exports.DOMNodeTransforms = DOMNodeTransforms;
exports.TRANSITION = TRANSITION;
exports.TRANSITION_GROUP = TRANSITION_GROUP;
exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
exports.V_MODEL_RADIO = V_MODEL_RADIO;
exports.V_MODEL_SELECT = V_MODEL_SELECT;
exports.V_MODEL_TEXT = V_MODEL_TEXT;
exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
exports.V_SHOW = V_SHOW;
exports.compile = compile;
exports.createDOMCompilerError = createDOMCompilerError;
exports.parserOptions = parserOptions;
exports.transformStyle = transformStyle;
//# sourceMappingURL=compiler-dom.esm-bundler.js.map
